import sys

original_ps1 = ">>>"
# global_exit = None
# failure_flag = False


class repl_hooks:
    def __init__(self):
        self.global_exit = None
        self.failure_flag = False
        self.original_excepthook = sys.excepthook
        self.original_displayhook = sys.displayhook
        sys.excepthook = self.my_excepthook
        sys.displayhook = self.my_displayhook

    def my_displayhook(self, value):
        if value is None:
            # did not fail
            self.failure_flag = False

        self.original_displayhook(value)

    def my_excepthook(self, type, value, traceback):
        self.global_exit = value
        self.failure_flag = True

        self.original_excepthook(type, value, traceback)


# def my_displayhook(value):
#     # print(value)
#     global failure_flag  # Tell Python we are using global failure_flag
#     if value is None:
#         # did not fail
#         failure_flag = False


# def my_excepthook(type, value, traceback):
#     global global_exit
#     global_exit = value
#     global failure_flag
#     failure_flag = True


class PS1:
    hooks = repl_hooks()
    sys.excepthook = hooks.my_excepthook
    sys.displayhook = hooks.my_displayhook

    def __str__(self):
        # This mechanism might fall over on caught errors?
        exit_code = 0
        if self.hooks.failure_flag:
            exit_code = 1
        else:
            exit_code = 0

        # Pythonic way :)
        result = f"{chr(27)}]633;D;{exit_code}0{chr(7)}{chr(27)}]633;A{chr(7)}{original_ps1}{chr(27)}]633;B{chr(7)}{chr(27)}]633;C{chr(7)}"

        # result = "{command_finished}{prompt_started}{prompt}{command_start}{command_executed}".format(
        #     command_finished="\x1b]633;D;" + str(exit_code) + "0\x07",
        #     prompt_started="\x1b]633;A\x07",
        #     prompt=original_ps1,
        #     command_start="\x1b]633;B\x07",
        #     # There's no preexec hook?
        #     command_executed="\x1b]633;C\x07",
        # )
        return result


sys.ps1 = PS1()
